// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String        @id @default(cuid())
  username    String?
  first_name  String?
  last_name   String?
  email       String        @unique
  password    String
  role        String        @default("user") // "admin" | "user"
  posts       Post[]
  userAddress UserAddress[]
  review      Review[]
  orders      Order[]
  invoices    Invoice[]
  gender      String?
  mobile      String?
  pic         String?
  createdAt   DateTime?     @default(now())
  updatedAt   DateTime?     @updatedAt
}

model UserAddress {
  id             String    @id @default(cuid())
  name           String?
  address_mobile String?
  street         String?
  city           String?
  state          String?
  postalCode     String?
  userId         String
  landmark       String?
  default        Boolean   @default(false)
  user           User      @relation(fields: [userId], references: [id])
  createdAt      DateTime? @default(now())
  updatedAt      DateTime? @updatedAt
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String?
  author    User?    @relation(fields: [authorId], references: [id])
}

model Category {
  id          Int        @id @default(autoincrement())
  name        String
  slug        String     @unique
  description String?
  image       String? // optional category image
  parentId    Int? // for sub-categories
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")

  // SEO fields
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?

  // Relations
  products Product[]

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Review {
  id        String   @id @default(cuid())
  rating    Int
  comment   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  productId Int

  user    User    @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

model Product {
  id                     Int                     @id @default(autoincrement())
  title                  String
  description            String
  additionalDescriptions AdditionalDescription[]
  reviews                Int                     @default(0)
  price                  Float
  discountedPrice        String?
  imgs                   ProductImage? // one-to-one
  tagImage               TagImage[] // many
  productOptions         ProductOption[]
  review                 Review[]
  faq                    FAQ[]
  categoryId             Int?
  category               Category?               @relation(fields: [categoryId], references: [id])
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
}

model AdditionalDescription {
  id        Int     @id @default(autoincrement())
  name      String?
  value     String?
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model ProductImage {
  id         Int      @id @default(autoincrement())
  thumbnails String[] // multiple URLs
  previews   String[]
  productId  Int      @unique
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model TagImage {
  id         Int      @id @default(autoincrement())
  thumbnails String[]
  previews   String[]
  tag        String
  productId  Int
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model ProductOption {
  id           Int                  @id @default(autoincrement())
  name         String
  type         String
  optionValues ProductOptionValue[]
  productId    Int
  product      Product              @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model ProductOptionValue {
  id       Int           @id @default(autoincrement())
  label    String
  value    Float
  discount Float         @default(0)
  optionId Int
  option   ProductOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
}

model FAQ {
  id        Int      @id @default(autoincrement())
  question  String
  answer    String
  // category    String?   // Optional: to group FAQs (e.g. "Shipping", "Payment")
  productId Int
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Invoice {
  id               Int      @id @default(autoincrement())
  stripeSessionId  String   @unique
  stripePaymentId  String? // payment_intent.id
  stripeCustomerId String?
  stripeInvoiceId  String? // optional if using Stripe invoicing API
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  customerEmail    String
  amountSubtotal   Int // before tax/discount (in cents)
  amountTax        Int? // optional
  amountDiscount   Int? // optional
  amountShipping   Int? // optional
  amountTotal      Int // total in cents
  currency         String
  status           String // 'pending' | 'paid' | 'refunded' | 'failed' | 'cancelled'
  paymentMethod    String? // e.g., 'card', 'upi', etc.
  invoicePdf       String? // Stripe provides hosted_invoice_url or pdf
  items            Json // line items snapshot
  metadata         Json? // flexible Stripe metadata
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  orders           Order[]
}

model Order {
  id              Int        @id @default(autoincrement())
  orderNumber     String     @unique // Unique identifier for frontend display
  userId          String
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoiceId       Int?
  invoice         Invoice?   @relation(fields: [invoiceId], references: [id])
  items           Json // Snapshot of purchased items (name, qty, price)
  subtotalAmount  Int
  taxAmount       Int?
  shippingAmount  Int?
  discountAmount  Int?
  totalAmount     Int
  currency        String
  paymentStatus   String // 'unpaid' | 'paid' | 'refunded' | 'failed'
  orderStatus     String // 'processing' | 'shipped' | 'delivered' | 'cancelled' | 'returned'
  paymentIntentId String? // Stripe payment intent
  refundId        String? // Stripe refund reference if refunded
  notes           String?
  deliveryAddress Json?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  cancelReason    String?
  cancelledAt     DateTime?
  logs            OrderLog[]
  isRead          String?    @default("unread")
}

model OrderLog {
  id        Int      @id @default(autoincrement())
  orderId   Int
  message   String
  createdAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])
}
